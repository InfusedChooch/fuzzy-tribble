# launcher.py
# GUI launcher for starting, stopping, and managing the HallPass server with CustomTkinter UI.

import os
import sys
import shutil
import socket
import threading
import subprocess
import webbrowser
import sqlite3
import json
import csv
import time
import pandas as pd
import tkinter as tk               # only for Menu and PhotoImage
from tkinter import messagebox    # use the standard messagebox
from datetime import datetime
from collections import defaultdict
from importlib import import_module
import contextlib
from functools import partial

import customtkinter as ctk       # <<< NEW: replace ttk and most tkinter widgets

# â”€â”€â”€ customtkinter THEME SETUP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ctk.set_appearance_mode("System")    # â€œLightâ€ / â€œDarkâ€ / â€œSystem"
ctk.set_default_color_theme("blue")  #  â€œblueâ€, â€œgreenâ€, â€œdark-blue", or your own theme JSON

IS_WINDOWS               = sys.platform.startswith("win")
CREATE_NEW_PROCESS_GROUP = 0x00000200
SERVER_EXE_NAME          = "hallpass_server.exe"

server_process = None
console_text   = None
statusbar      = None
server_pid     = None

# â”€â”€â”€ helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def get_local_ip():
    try:
        return socket.gethostbyname(socket.gethostname())
    except Exception:
        return "Unavailable"

def log(msg: str):
    if console_text:
        console_text.insert("end", msg + "\n")
        console_text.see("end")

def browser(url: str):
    webbrowser.open_new_tab(url)

def get_exe_path(rel: str):
    base = getattr(sys, "_MEIPASS", os.path.abspath("."))
    return os.path.join(base, rel)

# â”€â”€â”€ audit log tailing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def stream_audit_log():
    log_path = os.path.join("data", "logs", "console_audit.log")
    os.makedirs(os.path.dirname(log_path), exist_ok=True)

    if not os.path.exists(log_path):
        with open(log_path, "w", encoding="utf-8") as f:
            f.write("ðŸ” Audit log initialized.\n")

    def _follow():
        try:
            with open(log_path, "r", encoding="utf-8", errors="replace") as f:
                f.seek(0, os.SEEK_END)
                while True:
                    line = f.readline()
                    if not line:
                        time.sleep(1)
                        continue
                    if console_text:
                        clean_line = line.replace("Ã¢â‚¬â€œ", "-").replace("Ã¢â‚¬â€", "-")
                        console_text.insert("end", clean_line)
                        console_text.see("end")
        except Exception as e:
            if console_text:
                console_text.insert("end", f"[Audit tail error] {e}\n")
                console_text.see("end")

    threading.Thread(target=_follow, daemon=True).start()

# â”€â”€â”€ launch / stop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def launch_server(mode: str, port: str, notebook):
    global server_process, statusbar, server_pid

    if console_text is None:
        messagebox.showerror("Console Not Ready", "Please wait for the GUI to load before launching.")
        return
    if server_process and server_process.poll() is None:
        messagebox.showinfo("Already running", "A server is already running.")
        return

    console_text.delete("1.0", "end")
    log(f"Launching {mode.upper()} on port {port}â€¦")
    statusbar.configure(text=f"Launching {mode}â€¦")

    base = os.path.dirname(__file__)
    vpy  = sys.executable
    bundled_srv = os.path.join(os.path.dirname(sys.executable), SERVER_EXE_NAME)

    if os.path.exists(bundled_srv):
        cmd = [bundled_srv, f"--port={port}"]
    else:
        if mode == "main":
            cmd = [vpy, "-u", os.path.join(base, "main.py")]
        else:
            wsgi_cli = shutil.which("waitress-serve")
            if not wsgi_cli:
                log("âŒ waitress-serve not found. Install Waitress or bundle hallpass_server.exe.")
                return
            cmd = [wsgi_cli, "--call", f"--port={port}", "wsgi:get_app"]

    flags = CREATE_NEW_PROCESS_GROUP if (mode == "main" and IS_WINDOWS) else 0

    def stream():
        global server_process, server_pid
        try:
            server_process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                text=True,
                bufsize=1,
                creationflags=flags
            )
            server_pid = server_process.pid
            statusbar.configure(text=f"Server running (PID {server_pid})")
            for line in server_process.stdout:
                log(line.rstrip())
        except Exception as exc:
            log(f"âŒ Launch error: {exc}")
            server_process = None
            server_pid     = None

    threading.Thread(target=stream, daemon=True).start()


def stop_server():
    global server_process, statusbar, server_pid

    if not server_process:
        log("â„¹ï¸ No server running.")
        statusbar.configure(text="No server to stop")
        return

    try:
        if server_process.poll() is not None:
            log("â„¹ï¸ Server already exited.")
            server_process = None
            return

        log(f"ðŸ›‘ Attempting to stop server (PID {server_pid})â€¦")
        statusbar.configure(text="Stopping serverâ€¦")

        if IS_WINDOWS:
            log("ðŸ›‘ Sending CTRL+BREAK")
            server_process.send_signal(subprocess.signal.CTRL_BREAK_EVENT)
        else:
            log("ðŸ›‘ Sending terminate()")
            server_process.terminate()

        try:
            server_process.wait(timeout=5)
        except subprocess.TimeoutExpired:
            log("âš ï¸ Terminate timeout - forcing kill()")
            server_process.kill()
            server_process.wait(timeout=5)
            log("ðŸ’¥ Forced kill succeeded.")

        log(f"âœ… Server process PID {server_pid} stopped.")
        statusbar.configure(text="Server stopped")

    except Exception as exc:
        log(f"âŒ Shutdown error: {exc}")
    finally:
        if server_process and server_process.stdout:
            try:
                server_process.stdout.close()
            except Exception as e:
                log(f"âš ï¸ Could not close stdout: {e}")
        server_process = None
        server_pid = None

# â”€â”€â”€ GUI Builder â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def build_gui():
    global console_text, statusbar

    # â”€â”€â”€ ROOT WINDOW â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    root = ctk.CTk()  # <<< CUSTOMTKINTER window
    root.title("Server Launcher")
    root.geometry("1100x700")
    root.minsize(900, 600)

    # â”€â”€â”€ MENU BAR â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    menubar = tk.Menu(root)
    file_menu = tk.Menu(menubar, tearoff=0)
    file_menu.add_command(label='Export DBâ€¦', command=export_from_db)
    file_menu.add_separator()
    file_menu.add_command(label='Exit', command=lambda: (stop_server(), root.destroy()))
    menubar.add_cascade(label='File', menu=file_menu)

    tools_menu = tk.Menu(menubar, tearoff=0)
    tools_menu.add_command(label='Rebuild DB', command=trigger_rebuild)
    tools_menu.add_command(label='Split Masterlist', command=run_split_masterlist)
    menubar.add_cascade(label='Tools', menu=tools_menu)

    help_menu = tk.Menu(menubar, tearoff=0)
    help_menu.add_command(label='About', command=lambda: messagebox.showinfo('About', 'HallPass Launcher v1.0'))
    menubar.add_cascade(label='Help', menu=help_menu)

    root.config(menu=menubar)

    # â”€â”€â”€ TABVIEW â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    notebook = ctk.CTkTabview(root)
    notebook.pack(expand=True, fill="both", padx=10, pady=10)
    notebook.add("Server")
    notebook.add("Maintenance")
    notebook.add("Settings")

    # â”€â”€â”€ SERVER TAB â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    tab = notebook.tab("Server")
    
    # Port
    port_var = ctk.StringVar(value="5000")
    ctk.CTkLabel(tab, text="Port:", anchor="e", width=60).grid(row=0, column=0, padx=5, pady=5)
    ctk.CTkEntry(tab, textvariable=port_var, width=80).grid(row=0, column=1, padx=5, pady=5)

    # Launch / Stop Buttons
    ctk.CTkButton(tab, text="Launch via main.py", command=lambda: launch_server("main", port_var.get(), notebook))
    .grid(row=1, column=0, columnspan=2, padx=5, pady=5, sticky="ew")
    ctk.CTkButton(tab, text="Stop Server", command=stop_server)
    .grid(row=2, column=0, columnspan=2, padx=5, pady=5, sticky="ew")

    # Console Textbox
    console_text = ctk.CTkTextbox(tab, width=600, height=300)
    console_text.grid(row=3, column=0, columnspan=2, padx=5, pady=10, sticky="nsew")

    tab.rowconfigure(3, weight=1)
    tab.columnconfigure((0, 1), weight=1)

    # â”€â”€â”€ STATUS BAR â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    statusbar = ctk.CTkLabel(root, text="Ready", anchor="w")
    statusbar.pack(side="bottom", fill="x")

    # â”€â”€â”€ OTHER TABS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    render_maintenance_tab(notebook, port_var)
    render_settings_tab(notebook)

    # â”€â”€â”€ HEALTH CHECK & AUDIT STREAM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    threading.Thread(target=check_server_health, daemon=True).start()
    stream_audit_log()

    root.protocol("WM_DELETE_WINDOW", lambda: (stop_server(), root.destroy()))
    root.mainloop()

if __name__ == "__main__":
    build_gui()
